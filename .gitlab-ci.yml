stages:
  - build
  - test
  - deploy
  - DAST

variables:
  CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  DOCKER_IMAGE: $CONTAINER_TEST_IMAGE
  
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - vendor/

build: 
  stage: build
  image: composer:latest
  script:
    - composer install --prefer-dist --no-interaction
  artifacts:
    paths:
      - vendor/

build_image:
  services:
  - name: docker:dind
    alias: dind
  image: docker:20.10.16
  stage: build
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - docker build --tag $CONTAINER_TEST_IMAGE --tag $CI_REGISTRY_IMAGE:latest ./Docker
    - docker push $CONTAINER_TEST_IMAGE
    - docker push $CI_REGISTRY_IMAGE:latest
  needs: [build]
  rules:
    - changes:
        - Docker/**/*

cs:
  stage: test
  image: php:8.2
  script:
    - ./vendor/bin/php-cs-fixer fix src --dry-run --stop-on-violation # https://github.com/PHP-CS-Fixer/PHP-CS-Fixer

phpunit:
  stage: test
  image: php:8.2
  variables:
    APP_ENV: test
  script:
    - ./vendor/bin/phpunit # https://github.com/sebastianbergmann/phpunit

composer:
  stage: test
  image: composer:latest
  script:
    - composer normalize --diff --dry-run # https://github.com/ergebnis/composer-normalize
    - composer validate # https://getcomposer.org/doc/03-cli.md#validate
    - vendor/bin/composer-require-checker check --config-file=composer-require-checker.json # https://github.com/maglnet/ComposerRequireChecker
    - php8.2 vendor/bin/composer-unused # https://github.com/composer-unused/composer-unused
    - composer audit # https://getcomposer.org/doc/03-cli.md#audit

di: # чтобы проверить, что контейнер компилируется корректно в прод режиме
  stage: test
  image: php:8.2
  script:
    - bin/console cache:clear --env=prod
    - bin/console lint:container --env=prod

schema-validate: # проверить корректность маппингов доктрины, без соединения с бд
  stage: test
  image: php:8.2
  script:
    - bin/console doctrine:schema:validate --skip-sync

rector:
  stage: test
  image: php:8.2
  script:
    - vendor/rector/rector/bin/rector --dry-run

deptrac: # валидация архитектурных правил
  stage: test
  image: php:8.2
  script:
    - vendor/bin/deptrac --config-file=deptrac.modules.yaml --cache-file=var/.deptrac.modules.cache
    - vendor/bin/deptrac --config-file=deptrac.directories.yaml --cache-file=var/.deptrac.directories.cache

psalm: # проверка типов (и не только)
   stage: test
   image: php:8.2
   script:
     - vendor/bin/psalm

trivy_container_scan:
  image:
    name: docker.io/aquasec/trivy:latest
    entrypoint: [""]
  variables:
    # No need to clone the repo, we exclusively work on artifacts. See
    # https://docs.gitlab.com/ee/ci/runners/configure_runners.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  script:
    - trivy --version
    # update vulnerabilities db
    - time trivy image --download-db-only
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - time trivy image --exit-code 0 --format template --template "@/contrib/gitlab.tpl"
        --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
    # Prints full report
    - time trivy image --exit-code 0 "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - time trivy image --exit-code 1 --severity CRITICAL "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/ (Container Scanning report is available on GitLab EE Ultimate or GitLab.com Gold)
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json
  stage: test

kics-ioc-scan:
  stage: test
  image:
    name: checkmarx/kics:latest
    entrypoint: [""]
  script:
    - kics scan --no-progress -p ${PWD} -o ${PWD} --report-formats json --output-name kics-results
  artifacts:
    name: kics-results.json
    paths:
      - kics-results.json

gitleaks_secret_detection:
  stage: test
  image:
    name: zricethezav/gitleaks:latest
    entrypoint: [""]
  script:
    - gitleaks dir . --report-path gitleaks-report.json
  artifacts:
    paths:
      - gitleaks-report.json

deploy: # автоматическая доставка изменений на сервер (dev/stage/prod - для каждой будет своя джоба)
  stage: deploy
  when: manual
  only:
    - master   # или main/develop/release.x.x.x
  script:
    - echo "Deploying the application..."
#    здесь будет кастомная логика. в самом простом виде
#     - ssh $HOST:$USER \
#     && cd $PATH_TO_PROJECT \
#     && git clone $LINK \
#     && bin/console bin/console clear:cache \
#     && bin/console doctrine:migration:migrate
#  в более продвинутом варианте собираем docker image с кодом, vendor'ом, пушим в registry, и подменяем контейнер на сервере
    - echo "Application successfully deployed."

dast_nuclei:
  stage: DAST
  image: golang:latest
  variables:
    TARGET_URL: https://your-app/
  before_script:
    - go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
  script:
    - echo "Target url" $TARGET_URL
    - curl -I $TARGET_URL || echo "Target is unreachable"
    - nuclei -u $TARGET_URL -jsonl nuclei-report.jsonl || true
  artifacts:
    paths:
      - nuclei-report.jsonl
