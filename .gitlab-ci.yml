stages:
  - build
  - test
  - deploy
  - DAST

variables:
  DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

build:
  stage: build
  image: composer:latest
  script:
    - composer install --no-interaction
  artifacts:
    paths:
      - vendor/
      - .

build_image:
  services:
    - name: docker:dind
      alias: dind
  image: docker:20.10.16
  stage: build
  variables:
    GIT_STRATEGY: none
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
#    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - docker build --tag $DOCKER_IMAGE --tag $CI_REGISTRY_IMAGE:latest ./Docker
    - docker push $DOCKER_IMAGE
    - docker push $CI_REGISTRY_IMAGE:latest
  needs: [build]

cs:
  stage: test
  image: $DOCKER_IMAGE
  variables:
    GIT_STRATEGY: none
  script:
    - ./vendor/bin/php-cs-fixer fix src --dry-run --stop-on-violation # https://github.com/PHP-CS-Fixer/PHP-CS-Fixer

phpunit:
  stage: test
  image: $DOCKER_IMAGE
  services:
    - name: postgres:14
      alias: postgres
  variables:
    APP_ENV: test
    DATABASE_URL: "pgsql://postgres:postgres@postgres:5432/test_db"
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    GIT_STRATEGY: none
  script:
    - apt-get update && apt-get install -y postgresql-client
    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
    - bin/console doctrine:database:create --if-not-exists --env=test
    - bin/console doctrine:migrations:migrate --no-interaction --env=test
    - XDEBUG_MODE=coverage php ./vendor/bin/phpunit --coverage-text --coverage-cobertura=coverage.cobertura.xml --coverage-clover=coverage.xml
  coverage: '/^\s*Lines:\s*\d+.\d+\%/'
  artifacts:
    when: always
    paths:
      - coverage.cobertura.xml
      - coverage.xml

check_coverage:
  image: alpine:latest
  stage: test
  needs: [phpunit]
  variables:
    JOB_NAME: phpunit
    TARGET_BRANCH: master
    GIT_STRATEGY: none
  before_script:
    - apk add --update --no-cache curl jq
  rules:
    - if: '$CI_COMMIT_BRANCH != $TARGET_BRANCH'  # Only run on MRs, not on the main branch
  script:
    # Get the latest successful pipeline ID from the target branch
    - TARGET_PIPELINE_ID=$(curl -s "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines?ref=${TARGET_BRANCH}&status=success&private_token=${PRIVATE_TOKEN}" | jq ".[0].id")

    # Fetch the coverage percentage from the target branch's last successful pipeline
    - TARGET_COVERAGE=$(curl -s "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${TARGET_PIPELINE_ID}/jobs?private_token=${PRIVATE_TOKEN}" | jq --arg JOB_NAME "$JOB_NAME" '.[] | select(.name==$JOB_NAME) | .coverage' | tr -d '"')

    # Fetch the current coverage from this pipeline
    - CURRENT_COVERAGE=$(curl -s "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${CI_PIPELINE_ID}/jobs?private_token=${PRIVATE_TOKEN}" | jq --arg JOB_NAME "$JOB_NAME" '.[] | select(.name==$JOB_NAME) | .coverage' | tr -d '"')

    # Validate if coverage values are available
    - |
      if [ -z "$TARGET_COVERAGE" ]; then 
        echo "No previous coverage data found. Skipping check."; 
        exit 0;
      fi

    - |
      if [ -z "$CURRENT_COVERAGE" ]; then 
        echo "Failed to retrieve current coverage data."; 
        exit 1;
      fi

    # Convert to numeric and compare
    - |
      TARGET_COVERAGE=$(echo "$TARGET_COVERAGE" | awk '{print int($1)}')
      CURRENT_COVERAGE=$(echo "$CURRENT_COVERAGE" | awk '{print int($1)}')

      if [ "$CURRENT_COVERAGE" -lt "$TARGET_COVERAGE" ]; then 
        echo "Coverage decreased from ${TARGET_COVERAGE}% to ${CURRENT_COVERAGE}%! Merge request blocked.";
        exit 1;
      else 
        echo "Coverage check passed: ${CURRENT_COVERAGE}% (previous: ${TARGET_COVERAGE}%)";
      fi
  cache: {}

phpmd:
  stage: test
  image: $DOCKER_IMAGE
  variables:
    GIT_STRATEGY: none
  script:
    - vendor/bin/phpmd src json phpmd.xml --reportfile phpmd_result.json
  artifacts:
      when: always
      paths:
        - phpmd_result.json

migrations_rollback_test:
  stage: test
  image: $DOCKER_IMAGE
  services:
    - name: postgres:14
      alias: postgres
  variables:
    APP_ENV: test
    DATABASE_URL: "pgsql://postgres:postgres@postgres:5432/test_db"
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    GIT_STRATEGY: none
  script:
    - apt-get update && apt-get install -y postgresql-client
    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
    - bin/console doctrine:database:create --if-not-exists --env=test
    - bin/console doctrine:migrations:migrate --no-interaction --env=test
    - bin/console doctrine:migrations:migrate first --no-interaction --env=test
    - bin/console doctrine:migrations:migrate --no-interaction --env=test

composer:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DOCKER_IMAGE
  script:
    - composer normalize --diff --dry-run # https://github.com/ergebnis/composer-normalize
    - composer validate # https://getcomposer.org/doc/03-cli.md#validate
    - vendor/bin/composer-require-checker check --config-file=composer-require-checker.json # https://github.com/maglnet/ComposerRequireChecker
    - php8.2 vendor/bin/composer-unused # https://github.com/composer-unused/composer-unused
    - composer audit # https://getcomposer.org/doc/03-cli.md#audit
    - composer check-platform-reqs

di: # чтобы проверить, что контейнер компилируется корректно в прод режиме
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DOCKER_IMAGE
  script:
    - bin/console cache:clear --env=prod
    - bin/console lint:container --env=prod

schema-validate: # проверить корректность маппингов доктрины, без соединения с бд
  variables:
    GIT_STRATEGY: none  
  stage: test
  image: $DOCKER_IMAGE
  script:
    - bin/console doctrine:schema:validate --skip-sync

rector:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DOCKER_IMAGE
  script:
    - vendor/rector/rector/bin/rector --dry-run

deptrac: # валидация архитектурных правил
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DOCKER_IMAGE
  script:
    - vendor/bin/deptrac --config-file=deptrac.modules.yaml --cache-file=var/.deptrac.modules.cache
    - vendor/bin/deptrac --config-file=deptrac.directories.yaml --cache-file=var/.deptrac.directories.cache

psalm: # проверка типов (и не только)
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DOCKER_IMAGE
  script:
    - vendor/bin/psalm

trivy_container_scan:
  image:
    name: docker.io/aquasec/trivy:latest
    entrypoint: [""]
  variables:
    # No need to clone the repo, we exclusively work on artifacts. See
    # https://docs.gitlab.com/ee/ci/runners/configure_runners.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  script:
    - trivy --version
    # update vulnerabilities db
    - time trivy image --download-db-only
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - time trivy image --exit-code 0 --format template --template "@/contrib/gitlab.tpl"
        --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
    # Prints full report
    - time trivy image --exit-code 0 "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - time trivy image --exit-code 1 --severity CRITICAL "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/ (Container Scanning report is available on GitLab EE Ultimate or GitLab.com Gold)
  artifacts:
    when: always
    name: gl-container-scanning-report.json
    paths:
      - gl-container-scanning-report.json
    reports:
      container_scanning: gl-container-scanning-report.json
  stage: test

kics-iac-scan:
  stage: test
  image:
    name: checkmarx/kics:latest
    entrypoint: [""]
  script:
    - kics scan --no-progress -p ${PWD} -o ${PWD} --report-formats json --output-name kics-results
  artifacts:
    when: always
    name: kics-results.json
    paths:
      - kics-results.json

gitleaks_secret_detection:
  stage: test
  image:
    name: zricethezav/gitleaks:latest
    entrypoint: [""]
  script:
    - gitleaks dir . --report-path gitleaks-report.json
  artifacts:
    when: always
    paths:
      - gitleaks-report.json

deploy: # автоматическая доставка изменений на сервер (dev/stage/prod - для каждой будет своя джоба)
  stage: deploy
  when: manual
  only:
    - master   # или main/develop/release.x.x.x
  script:
    - echo "Deploying the application..."
#    здесь будет кастомная логика. в самом простом виде
#     - ssh $HOST:$USER \
#     && cd $PATH_TO_PROJECT \
#     && git clone $LINK \
#     && bin/console bin/console clear:cache \
#     && bin/console doctrine:migration:migrate
#  в более продвинутом варианте подменяем контейнер на сервере сбилженным image'м
    - echo "Application successfully deployed."

dast_nuclei:
  stage: DAST
  image: golang:latest
  variables:
    TARGET_URL: https://your-app/
  before_script:
    - go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
  script:
    - echo "Target url" $TARGET_URL
    - curl -I $TARGET_URL || echo "Target is unreachable"
    - nuclei -u $TARGET_URL -jsonl nuclei-report.jsonl || true
  artifacts:
    when: always
    paths:
      - nuclei-report.jsonl
