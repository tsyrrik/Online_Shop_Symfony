stages:
  - build
  - test
  - deploy
  - DAST

variables:
  DEV_IMAGE: $CI_REGISTRY_IMAGE:dev
  PROD_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

build_dev_dependencies:
  stage: build
  image: composer:latest
  script:
    - composer install --no-interaction
  artifacts:
    paths:
      - vendor/
      - .

build_dev_image:
  services:
    - name: docker:dind
      alias: dind
  image: docker:20.10.16
  stage: build
  variables:
    GIT_STRATEGY: none
  before_script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  script:
    - docker build -t $DEV_IMAGE ./.docker/dev
    - docker push $DEV_IMAGE
  needs: [build_dev_dependencies]

build_prod_dependencies:
  stage: build
  image: composer:latest
  variables:
    APP_ENV: prod
    APP_DEBUG: 0
  script:
    - cd app && composer install --no-dev --optimize-autoloader --no-interaction
    - cd app && composer dump-env prod
  artifacts:
    paths:
      - app/vendor/
      - app/.
  only:
    - tags

build_prod_image:
  services:
    - name: docker:dind
      alias: dind
  image: docker:20.10.16
  stage: build
  variables:
    GIT_STRATEGY: none
  before_script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  script:
    - docker build -t $PROD_IMAGE ./.docker/prod
    - docker push $PROD_IMAGE
    - docker push $CI_REGISTRY_IMAGE:latest
  needs: [build_prod_dependencies]
  only:
    - tags

cs:
  stage: test
  image: $DEV_IMAGE
  variables:
    GIT_STRATEGY: none
  script:
    - cd app && ./vendor/bin/php-cs-fixer -v --config=.php-cs-fixer.dist.php fix --dry-run --stop-on-violation --diff

phpunit:
  stage: test
  image: $DEV_IMAGE
  services:
    - name: postgres:14
      alias: postgres
  variables:
    APP_ENV: test
    DATABASE_URL: "pgsql://postgres:postgres@postgres:5432/test_db"
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    GIT_STRATEGY: none
  before_script:
    - apt-get update && apt-get install -y postgresql-client
    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
    - app/bin/console doctrine:database:create --if-not-exists
    - app/bin/console doctrine:migrations:migrate --no-interaction
  script:
    - cd app && XDEBUG_MODE=coverage php ./vendor/bin/phpunit --colors=never --coverage-text --coverage-cobertura=coverage.cobertura.xml --log-junit phpunit-report.xml --do-not-cache-result
  coverage: '/^\s*Lines:\s*\d+.\d+\%/'
  artifacts:
    when: always
    reports:
      junit: app/phpunit-report.xml
      coverage_report:
        coverage_format: cobertura
        path: app/coverage.cobertura.xml

composer:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DEV_IMAGE
  script:
    - cd app && composer normalize --diff --dry-run
    - cd app && composer validate
    - cd app && ./vendor/bin/composer-require-checker check --config-file=composer-require-checker.json
    - cd app && composer audit
    - cd app && composer check-platform-reqs

psalm:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DEV_IMAGE
  script:
    - cd app && ./vendor/bin/psalm --config=psalm.xml

di_lint:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DEV_IMAGE
  script:
    - app/bin/console cache:clear --env=prod
    - app/bin/console lint:container --env=prod

schema_validate:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DEV_IMAGE
  script:
    - app/bin/console doctrine:schema:validate --skip-sync

check_coverage:
  image: alpine:latest
  stage: test
  needs: [phpunit] 
  variables:
    JOB_NAME: phpunit
    TARGET_BRANCH: master
    GIT_STRATEGY: none
  before_script:
    - apk add --update --no-cache curl jq
  rules:
    - if: '$CI_COMMIT_BRANCH != $TARGET_BRANCH'
  script:
    - |
      # Get latest pipeline ID from the target branch using the PAT
      TARGET_PIPELINE_JSON=$(curl -s --header "PRIVATE-TOKEN: $CHECK_COVERAGE_TOKEN" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines?ref=${TARGET_BRANCH}") #todo add &status=success
      TARGET_PIPELINE_ID=$(echo "$TARGET_PIPELINE_JSON" | jq -r '.[0].id' 2>/dev/null)

    - |
      # Handle missing pipeline data
      if [ -z "$TARGET_PIPELINE_ID" ] || [ "$TARGET_PIPELINE_ID" = "null" ]; then
        echo "No previous coverage data found. Skipping check.";
        exit 0;
      fi

    - |
      # Fetch coverage from the target branch's last successful pipeline
      TARGET_JOBS_JSON=$(curl -s --header "PRIVATE-TOKEN: $CHECK_COVERAGE_TOKEN" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${TARGET_PIPELINE_ID}/jobs")
      TARGET_COVERAGE=$(echo "$TARGET_JOBS_JSON" | jq --arg JOB_NAME "$JOB_NAME" '.[] | select(.name==$JOB_NAME) | .coverage' | tr -d '"')
      echo "target coverage: $TARGET_COVERAGE"

    - |
      # Fetch current coverage from this pipeline
      CURRENT_JOBS_JSON=$(curl -s --header "PRIVATE-TOKEN: $CHECK_COVERAGE_TOKEN" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${CI_PIPELINE_ID}/jobs")
      CURRENT_COVERAGE=$(echo "$CURRENT_JOBS_JSON" | jq --arg JOB_NAME "$JOB_NAME" '.[] | select(.name==$JOB_NAME) | .coverage' | tr -d '"')
      echo "current coverage: $CURRENT_COVERAGE" 

    # Validate if coverage values are available
    - |
      if [ -z "$TARGET_COVERAGE" ]; then 
        echo "No previous coverage data found. Skipping check."; 
        exit 0;
      fi

    - |
      if [ -z "$CURRENT_COVERAGE" ]; then 
        echo "Failed to retrieve current coverage data."; 
        exit 1;
      fi

    - |
      # Convert to numeric but preserve decimals
      TARGET_COVERAGE_INT=$(echo "$TARGET_COVERAGE" | awk '{print int($1)}')
      CURRENT_COVERAGE_INT=$(echo "$CURRENT_COVERAGE" | awk '{print int($1)}')
      
      # Use bc for floating point comparison (will keep decimal precision)
      TARGET_COVERAGE_FLOAT=$(echo "$TARGET_COVERAGE" | sed 's/%//')
      CURRENT_COVERAGE_FLOAT=$(echo "$CURRENT_COVERAGE" | sed 's/%//')
      
      # Compare with decimals if both values are below 1%
      if (( $(echo "$TARGET_COVERAGE_FLOAT < 1" | bc -l) )) && (( $(echo "$CURRENT_COVERAGE_FLOAT < 1" | bc -l) )); then
        if (( $(echo "$CURRENT_COVERAGE_FLOAT < $TARGET_COVERAGE_FLOAT" | bc -l) )); then
          echo "Coverage decreased from ${TARGET_COVERAGE}% to ${CURRENT_COVERAGE}%! Merge request blocked.";
          exit 1;
        else 
          echo "Coverage check passed: ${CURRENT_COVERAGE}% (previous: ${TARGET_COVERAGE}%)";
        fi
      else
        # Use integer comparison for values >= 1%
        if [ "$CURRENT_COVERAGE_INT" -lt "$TARGET_COVERAGE_INT" ]; then 
          echo "Coverage decreased from ${TARGET_COVERAGE}% to ${CURRENT_COVERAGE}%! Merge request blocked.";
          exit 1;
        else 
          echo "Coverage check passed: ${CURRENT_COVERAGE}% (previous: ${TARGET_COVERAGE}%)";
        fi
      fi

deptrac:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DEV_IMAGE
  script:
    - cd app && ./vendor/bin/deptrac --config-file=deptrac.modules.yaml --cache-file=var/.deptrac.modules.cache
    - cd app && ./vendor/bin/deptrac --config-file=deptrac.directories.yaml --cache-file=var/.deptrac.directories.cache

migrations_rollback_test:
  stage: test
  image: $DEV_IMAGE
  services:
    - name: postgres:14
      alias: postgres
  variables:
    APP_ENV: test
    DATABASE_URL: "pgsql://postgres:postgres@postgres:5432/test_db"
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    GIT_STRATEGY: none
  before_script:
    - apt-get update && apt-get install -y postgresql-client
    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
    - app/bin/console doctrine:database:create --if-not-exists --env=test
    - app/bin/console doctrine:migrations:migrate --no-interaction --env=test
  script:
    - app/bin/console doctrine:migrations:migrate first --no-interaction --env=test

kics-iac-scan:
  stage: test
  image:
    name: checkmarx/kics:latest
    entrypoint: [""]
  script:
    - kics scan --no-progress -p ${PWD} -o ${PWD} --report-formats json --output-name kics-results
  artifacts:
    when: always
    name: kics-results.json
    paths:
      - kics-results.json

composer_outdated_check:
  stage: test
  image: composer:latest
  variables:
    GIT_STRATEGY: none
  script:
    - cd app && composer outdated --strict --major-only --sort-by-age
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

phpmd:
  stage: test
  image: $DEV_IMAGE
  variables:
    GIT_STRATEGY: none
  script:
    - cd app && ./vendor/bin/phpmd src json phpmd.xml --reportfile phpmd_result.json
  artifacts:
    when: always
    paths:
      - app/phpmd_result.json

comments_density:
  stage: test
  image: $DEV_IMAGE
  variables:
    GIT_STRATEGY: none
  script:
    - cd app && ./vendor/bin/comments_density analyze

rector:
  variables:
    GIT_STRATEGY: none
  stage: test
  image: $DEV_IMAGE
  script:
    - cd app && ./vendor/rector/rector/bin/rector --dry-run

trivy_container_scan:
  image:
    name: docker.io/aquasec/trivy:latest
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  script:
    - trivy --version
    - time trivy image --download-db-only
    - time trivy image --exit-code 0 --format template --template "@/contrib/gitlab.tpl"
        --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
    - time trivy image --exit-code 0 "$FULL_IMAGE_NAME"
    - time trivy image --exit-code 1 --severity CRITICAL "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  artifacts:
    when: always
    name: gl-container-scanning-report.json
    paths:
      - gl-container-scanning-report.json
    reports:
      container_scanning: gl-container-scanning-report.json
  stage: test

gitleaks_secret_detection:
  stage: test
  image:
    name: zricethezav/gitleaks:latest
    entrypoint: [""]
  script:
    - gitleaks dir . --report-path gitleaks-report.json
  artifacts:
    when: always
    paths:
      - gitleaks-report.json

deploy_dev:
  stage: deploy
  when: manual
  script:
    - echo "Deploying the application..."
#    здесь будет кастомная логика. в самом простом виде
#     - ssh $HOST:$USER \
#     && cd $PATH_TO_PROJECT \
#     && git pull \
#     && bin/console bin/console clear:cache \
#     && bin/console doctrine:migration:migrate
#  в более продвинутом варианте подменяем контейнер на сервере сбилженным image'м
    - echo "Application successfully deployed."

deploy_prod:
  stage: deploy
  when: manual
  only:
    - tags
  script:
    - echo "Deploying the application..."
    #    здесь будет кастомная логика. в самом простом виде
    #     - ssh $HOST:$USER \
    #     && cd $PATH_TO_PROJECT \
    #     && git pull \
    #     && bin/console bin/console clear:cache \
    #     && bin/console doctrine:migration:migrate
    #  в более продвинутом варианте подменяем контейнер на сервере сбилженным image'м
    - echo "Application successfully deployed."

nuclei:
  stage: DAST
  image: golang:latest
  variables:
    TARGET_URL: https://your-app/
  before_script:
    - go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
    - curl -I $TARGET_URL || echo "Target is unreachable"
  script:
    - nuclei -u $TARGET_URL -jsonl nuclei-report.jsonl || true
  artifacts:
    when: always
    paths:
      - nuclei-report.jsonl
