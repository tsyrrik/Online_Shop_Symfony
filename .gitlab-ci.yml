stages:
  - build
  - test
  - deploy
  - DAST

variables:
  DEV_IMAGE: $CI_REGISTRY_IMAGE:dev
  PROD_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

build_dev_dependencies:
  stage: build
  image: composer:latest
  script:
    - composer install --no-interaction
  artifacts:
    paths:
      - vendor/
      - .

build_dev_image:
  services:
    - name: docker:dind
      alias: dind
  image: docker:20.10.16
  stage: build
  variables:
    GIT_STRATEGY: none
  script:
    - docker build -t $DEV_IMAGE ./.docker/dev
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker push $DEV_IMAGE
  needs: [build_dev_dependencies]

build_prod_dependencies:
  stage: build
  image: composer:latest
  variables:
    APP_ENV: prod
    APP_DEBUG: 0
  script:
    - composer install --no-dev --optimize-autoloader --no-interaction
    - composer dump-env prod
  artifacts:
    paths:
      - vendor/
      - .
  only:
    - tags

build_prod_image:
  services:
    - name: docker:dind
      alias: dind
  image: docker:20.10.16
  stage: build
  variables:
    GIT_STRATEGY: none
  script:
    - docker build -t $PROD_IMAGE ./.docker/prod
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker push $PROD_IMAGE
    - docker push $CI_REGISTRY_IMAGE:latest
  needs: [build_prod_dependencies]
  only:
    - tags
#
#cs:
#  stage: test
#  image: $DEV_IMAGE
#  variables:
#    GIT_STRATEGY: none
#  script:
#    - ./vendor/bin/php-cs-fixer fix src --dry-run --stop-on-violation

phpunit:
  stage: test
  image: $DEV_IMAGE
  services:
    - name: postgres:14
      alias: postgres
  variables:
    APP_ENV: test
    DATABASE_URL: "pgsql://postgres:postgres@postgres:5432/test_db"
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    GIT_STRATEGY: none
  script:
    - apt-get update && apt-get install -y postgresql-client
    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
    - bin/console doctrine:database:create --if-not-exists
    - bin/console doctrine:migrations:migrate --no-interaction
    - XDEBUG_MODE=coverage php ./vendor/bin/phpunit --colors=never --coverage-text --coverage-cobertura=coverage.cobertura.xml
  coverage: '/^\s*Lines:\s*\d+.\d+\%/'
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.cobertura.xml

#composer:
#  variables:
#    GIT_STRATEGY: none
#  stage: test
#  image: $DEV_IMAGE
#  script:
#    - composer normalize --diff --dry-run # https://github.com/ergebnis/composer-normalize
#    - composer validate # https://getcomposer.org/doc/03-cli.md#validate
#    - vendor/bin/composer-require-checker check --config-file=composer-require-checker.json # https://github.com/maglnet/ComposerRequireChecker
#    - php8.2 vendor/bin/composer-unused # https://github.com/composer-unused/composer-unused
#    - composer audit # https://getcomposer.org/doc/03-cli.md#audit
#    - composer check-platform-reqs
#
#psalm:
#  variables:
#    GIT_STRATEGY: none
#  stage: test
#  image: $DEV_IMAGE
#  script:
#    - vendor/bin/psalm
#
#di: # чтобы проверить, что контейнер компилируется корректно в прод режиме
#  variables:
#    GIT_STRATEGY: none
#  stage: test
#  image: $DEV_IMAGE
#  script:
#    - bin/console cache:clear --env=prod
#    - bin/console lint:container --env=prod
#
#schema-validate: # проверить корректность маппингов доктрины, без соединения с бд
#  variables:
#    GIT_STRATEGY: none
#  stage: test
#  image: $DEV_IMAGE
#  script:
#    - bin/console doctrine:schema:validate --skip-sync
#
#rector:
#  variables:
#    GIT_STRATEGY: none
#  stage: test
#  image: $DEV_IMAGE
#  script:
#    - vendor/rector/rector/bin/rector --dry-run

check_coverage:
  image: alpine:latest
  stage: test
  needs: [phpunit]
  variables:
    JOB_NAME: phpunit
    TARGET_BRANCH: master
    GIT_STRATEGY: none
  before_script:
    - apk add --update --no-cache curl jq
  rules:
    - if: '$CI_COMMIT_BRANCH != $TARGET_BRANCH'
  script:
    - |
      # Get latest successful pipeline ID from the target branch using the PAT
      TARGET_PIPELINE_JSON=$(curl -s --header "PRIVATE-TOKEN: $CHECK_COVERAGE_TOKEN" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines?ref=${TARGET_BRANCH}") #todo add &status=success
      echo "Received API Response: $TARGET_PIPELINE_JSON"
      TARGET_PIPELINE_ID=$(echo "$TARGET_PIPELINE_JSON" | jq -r '.[0].id' 2>/dev/null)
      echo "DEBUG: Selected pipeline ID: $TARGET_PIPELINE_ID"

    - |
      # Handle missing pipeline data
      if [ -z "$TARGET_PIPELINE_ID" ] || [ "$TARGET_PIPELINE_ID" = "null" ]; then
        echo "No previous coverage data found. Skipping check.";
        exit 0;
      fi

    - |
      # Fetch coverage from the target branch's last successful pipeline
      TARGET_JOBS_JSON=$(curl -s --header "PRIVATE-TOKEN: $CHECK_COVERAGE_TOKEN" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${TARGET_PIPELINE_ID}/jobs")
      echo "DEBUG: Target jobs JSON: $TARGET_JOBS_JSON"
      TARGET_COVERAGE=$(echo "$TARGET_JOBS_JSON" | jq --arg JOB_NAME "$JOB_NAME" '.[] | select(.name==$JOB_NAME) | .coverage' | tr -d '"')
      echo "DEBUG: Raw target coverage value: $TARGET_COVERAGE"
      echo "target coverage: $TARGET_COVERAGE"

    - |
      # Fetch current coverage from this pipeline
      CURRENT_JOBS_JSON=$(curl -s --header "PRIVATE-TOKEN: $CHECK_COVERAGE_TOKEN" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${CI_PIPELINE_ID}/jobs")
      echo "DEBUG: Current jobs JSON: $CURRENT_JOBS_JSON" 
      CURRENT_COVERAGE=$(echo "$CURRENT_JOBS_JSON" | jq --arg JOB_NAME "$JOB_NAME" '.[] | select(.name==$JOB_NAME) | .coverage' | tr -d '"')
      echo "DEBUG: Raw current coverage value: $CURRENT_COVERAGE"
      echo "current coverage: $CURRENT_COVERAGE" 

    # Validate if coverage values are available
    - |
      if [ -z "$TARGET_COVERAGE" ]; then 
        echo "No previous coverage data found. Skipping check."; 
        exit 0;
      fi

    - |
      if [ -z "$CURRENT_COVERAGE" ]; then 
        echo "Failed to retrieve current coverage data."; 
        exit 1;
      fi

    - |
      # DEBUG: Print raw values before conversion
      echo "DEBUG: Target coverage before conversion: $TARGET_COVERAGE"
      echo "DEBUG: Current coverage before conversion: $CURRENT_COVERAGE"
      
      # Convert to numeric but preserve decimals
      TARGET_COVERAGE_INT=$(echo "$TARGET_COVERAGE" | awk '{print int($1)}')
      CURRENT_COVERAGE_INT=$(echo "$CURRENT_COVERAGE" | awk '{print int($1)}')
      
      # Use bc for floating point comparison (will keep decimal precision)
      TARGET_COVERAGE_FLOAT=$(echo "$TARGET_COVERAGE" | sed 's/%//')
      CURRENT_COVERAGE_FLOAT=$(echo "$CURRENT_COVERAGE" | sed 's/%//')
      
      echo "DEBUG: TARGET_COVERAGE_INT: $TARGET_COVERAGE_INT"
      echo "DEBUG: CURRENT_COVERAGE_INT: $CURRENT_COVERAGE_INT"
      echo "DEBUG: TARGET_COVERAGE_FLOAT: $TARGET_COVERAGE_FLOAT"
      echo "DEBUG: CURRENT_COVERAGE_FLOAT: $CURRENT_COVERAGE_FLOAT"

      # Compare with decimals if both values are below 1%
      if (( $(echo "$TARGET_COVERAGE_FLOAT < 1" | bc -l) )) && (( $(echo "$CURRENT_COVERAGE_FLOAT < 1" | bc -l) )); then
        echo "DEBUG: Both values are below 1%, comparing with decimal precision"
        if (( $(echo "$CURRENT_COVERAGE_FLOAT < $TARGET_COVERAGE_FLOAT" | bc -l) )); then
          echo "Coverage decreased from ${TARGET_COVERAGE}% to ${CURRENT_COVERAGE}%! Merge request blocked.";
          exit 1;
        else 
          echo "Coverage check passed: ${CURRENT_COVERAGE}% (previous: ${TARGET_COVERAGE}%)";
        fi
      else
        # Use integer comparison for values >= 1%
        if [ "$CURRENT_COVERAGE_INT" -lt "$TARGET_COVERAGE_INT" ]; then 
          echo "Coverage decreased from ${TARGET_COVERAGE}% to ${CURRENT_COVERAGE}%! Merge request blocked.";
          exit 1;
        else 
          echo "Coverage check passed: ${CURRENT_COVERAGE}% (previous: ${TARGET_COVERAGE}%)";
        fi
      fi
#
#migrations_rollback_test:
#  stage: test
#  image: $DEV_IMAGE
#  services:
#    - name: postgres:14
#      alias: postgres
#  variables:
#    APP_ENV: test
#    DATABASE_URL: "pgsql://postgres:postgres@postgres:5432/test_db"
#    POSTGRES_DB: test_db
#    POSTGRES_USER: postgres
#    POSTGRES_PASSWORD: postgres
#    GIT_STRATEGY: none
#  script:
#    - apt-get update && apt-get install -y postgresql-client
#    - until pg_isready -h postgres -p 5432 -U postgres; do sleep 1; done
#    - bin/console doctrine:database:create --if-not-exists --env=test
#    - bin/console doctrine:migrations:migrate --no-interaction --env=test
#    - bin/console doctrine:migrations:migrate first --no-interaction --env=test
#    - bin/console doctrine:migrations:migrate --no-interaction --env=test
#
#phpmd:
#  stage: test
#  image: $DEV_IMAGE
#  variables:
#    GIT_STRATEGY: none
#  script:
#    - vendor/bin/phpmd src json phpmd.xml --reportfile phpmd_result.json
#  artifacts:
#    when: always
#    paths:
#      - phpmd_result.json
#
#deptrac:
#  variables:
#    GIT_STRATEGY: none
#  stage: test
#  image: $DEV_IMAGE
#  script:
#    - vendor/bin/deptrac --config-file=deptrac.modules.yaml --cache-file=var/.deptrac.modules.cache
#    - vendor/bin/deptrac --config-file=deptrac.directories.yaml --cache-file=var/.deptrac.directories.cache
#
#kics-iac-scan:
#  stage: test
#  image:
#    name: checkmarx/kics:latest
#    entrypoint: [""]
#  script:
#    - kics scan --no-progress -p ${PWD} -o ${PWD} --report-formats json --output-name kics-results
#  artifacts:
#    when: always
#    name: kics-results.json
#    paths:
#      - kics-results.json
#
#trivy_container_scan:
#  image:
#    name: docker.io/aquasec/trivy:latest
#    entrypoint: [""]
#  variables:
#    # No need to clone the repo, we exclusively work on artifacts. See
#    # https://docs.gitlab.com/ee/ci/runners/configure_runners.html#git-strategy
#    GIT_STRATEGY: none
#    TRIVY_USERNAME: "$CI_REGISTRY_USER"
#    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
#    TRIVY_AUTH_URL: "$CI_REGISTRY"
#    TRIVY_NO_PROGRESS: "true"
#    TRIVY_CACHE_DIR: ".trivycache/"
#    FULL_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
#  script:
#    - trivy --version
#    # update vulnerabilities db
#    - time trivy image --download-db-only
#    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
#    - time trivy image --exit-code 0 --format template --template "@/contrib/gitlab.tpl"
#        --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
#    # Prints full report
#    - time trivy image --exit-code 0 "$FULL_IMAGE_NAME"
#    # Fail on critical vulnerabilities
#    - time trivy image --exit-code 1 --severity CRITICAL "$FULL_IMAGE_NAME"
#  cache:
#    paths:
#      - .trivycache/
#  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/ (Container Scanning report is available on GitLab EE Ultimate or GitLab.com Gold)
#  artifacts:
#    when: always
#    name: gl-container-scanning-report.json
#    paths:
#      - gl-container-scanning-report.json
#    reports:
#      container_scanning: gl-container-scanning-report.json
#  stage: test
#
#gitleaks_secret_detection:
#  stage: test
#  image:
#    name: zricethezav/gitleaks:latest
#    entrypoint: [""]
#  script:
#    - gitleaks dir . --report-path gitleaks-report.json
#  artifacts:
#    when: always
#    paths:
#      - gitleaks-report.json
#
#deploy_dev:
#  stage: deploy
#  when: manual
#  script:
#    - echo "Deploying the application..."
##    здесь будет кастомная логика. в самом простом виде
##     - ssh $HOST:$USER \
##     && cd $PATH_TO_PROJECT \
##     && git pull \
##     && bin/console bin/console clear:cache \
##     && bin/console doctrine:migration:migrate
##  в более продвинутом варианте подменяем контейнер на сервере сбилженным image'м
#    - echo "Application successfully deployed."
#
#deploy_prod:
#  stage: deploy
#  when: manual
#  only:
#    - tags
#  script:
#    - echo "Deploying the application..."
#    #    здесь будет кастомная логика. в самом простом виде
#    #     - ssh $HOST:$USER \
#    #     && cd $PATH_TO_PROJECT \
#    #     && git pull \
#    #     && bin/console bin/console clear:cache \
#    #     && bin/console doctrine:migration:migrate
#    #  в более продвинутом варианте подменяем контейнер на сервере сбилженным image'м
#    - echo "Application successfully deployed."
#
#dast_nuclei:
#  stage: DAST
#  image: golang:latest
#  variables:
#    TARGET_URL: https://your-app/
#  before_script:
#    - go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
#  script:
#    - echo "Target url" $TARGET_URL
#    - curl -I $TARGET_URL || echo "Target is unreachable"
#    - nuclei -u $TARGET_URL -jsonl nuclei-report.jsonl || true
#  artifacts:
#    when: always
#    paths:
#      - nuclei-report.jsonl
